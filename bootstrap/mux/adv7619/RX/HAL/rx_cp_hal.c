/**********************************************************************************************
*																						      *
* Copyright (c) 2015 Analog Devices, Inc.  All Rights Reserved.                               *
* This software is proprietary and confidential to Analog Devices, Inc. and its licensors.    *
*                                                                                             *
***********************************************************************************************/
#include "rx_lib.h"

#if (RX_DEVICE==7604||RX_DEVICE==7614||RX_DEVICE == 7840\
    ||RX_DEVICE==7844||RX_DEVICE == 7842||RX_DEVICE == 7850||RX_DEVICE==7186)

#include "rx_isr.h"

EXTERNAL CONSTANT UCHAR StdiModeCfg[];
EXTERNAL CONSTANT UCHAR SspdModeCfg[];
EXTERNAL CONSTANT UCHAR SyncChSourceCfg[];
/*============================================================================
 * Retun the gain mode
 *
 * Entry:   GainMode: RX_GAIN_AUTO = Gain automatically computed and dependant
 *                                   the output range
 *                    RX_GAIN_AGC =  Gain generated by the AGC section
 *                    RX_GAIN_MAN = Gain manually set by user
 *
 * Return:  ATVERR_OK = Function completed successfully
 *
 * Notes:   See also ADIAPI_RxCpSetGain
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetGainMode (RX_GAIN_MODE *GainMode)
{
    UINT8 AgcMode;
    UINT8 GainMan;
    
    
    VRX_get_AGC_MODE_MAN(&AgcMode);
    VRX_get_GAIN_MAN(&GainMan);
    if(AgcMode)
    {
        if(GainMan)
        {
            *GainMode = RX_GAIN_MAN;
        }
        else
        {
            *GainMode = RX_GAIN_AGC;
        }
    }
    else
    {
        *GainMode = RX_GAIN_AUTO;
    }
    return (ATVERR_OK);
}

/*============================================================================
 * This function enables manual mode gain and sets the gain for each processing c
 * channel of the CP core.
 * 
 * Entry:   GainChA:  Channel A Gain
 *          GainChB:  Channel B Gain
 *          GainChC:  Channel C Gain
 *          
 *  
 * Return:  ATVERR_OK
 *          
 * Notes:   The gain registers are sequenced and should be written to in order
 *          with no other I2C activity in between.
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetGain (UINT16 GainChA, UINT16 GainChB, UINT16 GainChC)
{
    UINT16 GainWrSeq[4];

    GainWrSeq[0]= ((GainChA >> 4) & 0x3FF) | (0xC0);
    GainWrSeq[1]= (((GainChA & 0x00F) << 4) | ( (GainChB & 0x3C0) >>6));
    GainWrSeq[2]= (((GainChB & 0x03F) << 2) | ( (GainChC & 0x300) >>8));
    GainWrSeq[3]= ( GainChC & 0x0FF);
    HAL_I2CWriteByte(VRX_CP_MAP_ADDR,VRX_REG_GAIN_CNTRL_3 , GainWrSeq[0]); 
    HAL_I2CWriteByte(VRX_CP_MAP_ADDR,VRX_REG_GAIN_CNTRL_4, GainWrSeq[1]);
    HAL_I2CWriteByte(VRX_CP_MAP_ADDR,VRX_REG_GAIN_CNTRL_5, GainWrSeq[2]);
    HAL_I2CWriteByte(VRX_CP_MAP_ADDR,VRX_REG_GAIN_CNTRL_6, GainWrSeq[3]);
    return (ATVERR_OK);
}
/*==========================================================================
 * Finds out all the active nad unmasked CP interrupts. It clears all the 
 * active interupts on return.
 *
 * Entry:   RxCpInts = is a BOOL array that contains status of all the HDMI
 *                      interrupts
 * 
 * Notes:  None
 *=========================================================================*/
void HAL_RxCpGetInterrupts(RX_CP_INTERRUPTS *RxCpInts)
{
    UINT8 IntStatus1, IntStatus6;
        
    HAL_I2CReadByte(VRX_IO_MAP_ADDR, VRX_REG_INTERRUPT_STATUS_1, &IntStatus1);
    HAL_I2CReadByte(VRX_IO_MAP_ADDR, VRX_REG_INTERRUPT_STATUS_6, &IntStatus6);

     
    RxCpInts->CpLckChng = (BOOL) ((IntStatus1 & VRX_BIT_CP_LOCK_ST) | 
                                  (IntStatus1 & VRX_BIT_CP_UNLOCK_ST));
    RxCpInts->StdiLckChng = (BOOL) (IntStatus1 & VRX_BIT_STDI_DATA_VALID_ST);    
    RxCpInts->CpCh1LckChng = (BOOL) ((IntStatus6 & VRX_BIT_CP_LOCK_CH1_ST) | 
                                    (IntStatus6 & VRX_BIT_CP_UNLOCK_CH1_ST));
    RxCpInts->StdiCh1LckChng = (BOOL) (IntStatus6 & VRX_BIT_STDI_DVALID_CH1_ST);
    RxCpInts->CpCh2LckChng = (BOOL) ((IntStatus6 & VRX_BIT_CP_LOCK_CH2_ST) | 
                                    (IntStatus6 & VRX_BIT_CP_UNLOCK_CH2_ST));
    RxCpInts->StdiCh2LckChng = (BOOL) (IntStatus6 & VRX_BIT_STDI_DVALID_CH2_ST);
  
  	/* =========================================================================================
  	 * The below is done so that we only clear the interrupts that we're currently interested in
  	 * This way we don't inadvertently clear something that another function might need to look at
  	 * ===========================================================================================*/
  	IntStatus1 = RxCpInts->CpLckChng | RxCpInts->StdiLckChng;
  	IntStatus6 = RxCpInts->CpCh1LckChng | RxCpInts->StdiCh1LckChng | RxCpInts->CpCh2LckChng | RxCpInts->StdiCh2LckChng;
  	 
  	/*==================================================================
    * Acknowledge all interrupts immediately so we don't lose any
    *=================================================================*/
    HAL_I2CWriteByte(VRX_IO_MAP_ADDR, VRX_REG_INTERRUPT_CLEAR_1, IntStatus1);
    HAL_I2CWriteByte(VRX_IO_MAP_ADDR, VRX_REG_INTERRUPT_CLEAR_6, IntStatus6);
}


/*============================================================================
 * Select the type of sync that is used by a specific syn channel
 *
 * Entry:   SyncSrc: type of sync processed by the sync channel SyncCh 
 *          SyncCh: Sync channel to which sync must be routed to        
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpEnSyncChAutoMode, ADIAPI_RxCpSetMainSyncCh
 *          ADIAPI_RxCpGetMainSyncCh
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetSyncChSource (RX_SYNC_SRC SyncSrc, RX_SYNC_CH SyncCh)
{
    UINT8 i;

    
    i = (UCHAR)(ATV_LookupValue8 ((UCHAR*)SyncChSourceCfg, 
                                                (UCHAR)SyncSrc, 0xff, 2));
    if(SyncChSourceCfg[i] == 0xff)
    {
        return (ATVERR_INV_PARM);
    }
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            VRX_set_CH1_SYNC_SRC(SyncChSourceCfg[i+1]);   
            break;
        case RX_SYNC_CH2:
            VRX_set_CH2_SYNC_SRC(SyncChSourceCfg[i+1]);   
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Set the selection mode of the sync channel processed by the CP section
 *
 * Entry:   Enable : ATV_TRUE =  Enable automatic selection of the sync 
 *                               channel processed by the CP section
 *                   ATV_FALSE =  Enable manual selection of the sync 
 *                               channel processed by the CP section        
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *
 * Notes:   See also ADIAPI_RxCpRouteSyncToSyncCh, ADIAPI_RxCpSetMainSyncCh
 *          ADIAPI_RxCpGetMainSyncCh
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpEnSyncChAutoMode (BOOL Enable)
{
    Enable &= 1;
    VRX_set_SYNC_CH_AUTO_MODE((UINT8)Enable);
    return (ATVERR_OK);
}

/*============================================================================
 * Set the sync channel that is proccesed in manual sync selection mode.
 * Set the priority order of the sync processed by the CP section in automatic 
 * sync selection mode. 
 *
 * Entry:   SyncCh : The CP section processes channel SyncCh in 
 *                   manual sync selection mode.
 *                   The CP section prioritarily processes channel SyncCh in 
 *                   automatic sync selection mode.     
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpRouteSyncToSyncCh, ADIAPI_RxCpEnSyncChAutoMode,
 *          ADIAPI_RxCpGetMainSyncCh
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetMainSyncCh (RX_SYNC_CH SyncCh)
{
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            VRX_set_SYNC_CH1_PRIORITY(1);
            break;
        case RX_SYNC_CH2:
            VRX_set_SYNC_CH1_PRIORITY(0);
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Return the sync channel that is being processed by the CP section
 *
 * Entry:   SyncCh : The CP section is currently processing channel SyncCh  
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *
 * Notes:   See also ADIAPI_RxCpRouteSyncToSyncCh, ADIAPI_RxCpEnSyncChAutoMode,
 *          ADIAPI_RxCpSetMainSyncCh
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetMainSyncCh (RX_SYNC_CH *SyncCh)
{
    if(VRX_is_SEL_SYNC_CHANNEL_true())
    {
        *SyncCh = RX_SYNC_CH1;
    }
    else
    {
        *SyncCh = RX_SYNC_CH2;
    }
    return (ATVERR_OK);
}



/*============================================================================
 * Set the SSPD measurement mode
 *
 * Entry:   SspdMode: Sets the SSPD measurement mode
 *          SyncCh: Sync channel for which the SSPD measurement mode must be 
 *                  set
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCPGetSspdMsrmt
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetSspdMode (RX_CP_MSRMT_MODE SspdMode, RX_SYNC_CH SyncCh)
{
    UINT8 i;

    
    i = (UCHAR)(ATV_LookupValue8 ((UCHAR*)SspdModeCfg, 
                                                (UCHAR)SspdMode, 0xff, 2));
    if(SspdModeCfg[i] == 0xff)
    {
        return (ATVERR_INV_PARM);
    }
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            VRX_set_CH1_SSPD_CONT(SspdModeCfg[i+1]);   
            break;
        case RX_SYNC_CH2:
            VRX_set_CH2_SSPD_CONT(SspdModeCfg[i+1]);   
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Return the SSPD measurement for a selected sync channel
 *
 * Entry:   SspdInfo: SSPD measurement
 *          SyncCh: Sync channel for which the SSPD measurement must be 
 *                  returned
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_FAILED = Valid SSPD measurement not available
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpSetSspdMode
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetSspdMsrmt (RX_SSPD_INFO *SspdInfo, RX_SYNC_CH SyncCh)
{
    UINT8 SyncSrcRb;
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            if(!VRX_is_CH1_SSPD_CONT_true())
            {
                VRX_set_CH1_TRIG_SSPD(1);
                VRX_set_CH1_TRIG_SSPD(0);
            }
            SyncSrcRb = VRX_ret_CH1_CUR_SYNC_SRC();
            SspdInfo->VsAct = VRX_is_CH1_VS_ACT_true();
            SspdInfo->PolVs = VRX_is_CH1_CUR_POL_VS_true();
            SspdInfo->HsCsAct = VRX_is_CH1_HS_ACT_true();
            SspdInfo->PolHsCs = VRX_is_CH1_CUR_POL_HS_true();
            if(!VRX_is_CH1_SSPD_DVALID_true())
            {
                return (ATVERR_FAILED);
            }
            switch(SyncSrcRb)
            {
                case 0:
                    return (ATVERR_FAILED);
                case 1:
                    SspdInfo->SyncSrc = RX_HS_VS;
                    break;
                case 2:
                    SspdInfo->SyncSrc = RX_HS_CS;
                    break;
                case 3:
                    SspdInfo->SyncSrc = RX_EMB_SYNC;
                    break;
                case 4:
                    return (ATVERR_FAILED);
            }
            break;
        case RX_SYNC_CH2:
            if(!VRX_is_CH2_SSPD_CONT_true())
            {
                VRX_set_CH2_TRIG_SSPD(1);
                VRX_set_CH2_TRIG_SSPD(0);
            }
            SyncSrcRb = VRX_ret_CH2_CUR_SYNC_SRC();
            SspdInfo->VsAct = VRX_is_CH2_VS_ACT_true();
            SspdInfo->PolVs = VRX_is_CH2_CUR_POL_VS_true();
            SspdInfo->HsCsAct = VRX_is_CH2_HS_ACT_true();
            SspdInfo->PolHsCs = VRX_is_CH2_CUR_POL_HS_true();
            if(!VRX_is_CH2_SSPD_DVALID_true())
            {
                return (ATVERR_FAILED);
            }
            switch(SyncSrcRb)
            {
                case 0:
                    return (ATVERR_FAILED);
                case 1:
                    SspdInfo->SyncSrc = RX_HS_VS;
                    break;
                case 2:
                    SspdInfo->SyncSrc = RX_HS_CS;
                    break;
                case 3:
                    SspdInfo->SyncSrc = RX_EMB_SYNC;
                    break;
                case 4:
                    return (ATVERR_FAILED);
            }
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Returns the lock status of the SSPD for a selected sync channel
 *
 * Entry:   Locked: lock status of the SSPD in sync channel SyncCh
 *          SyncCh: Sync channel for which the STDI lock status must be 
 *                  returned           
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetSspdStatus (BOOL *Locked, RX_SYNC_CH SyncCh)
{
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            *Locked = VRX_is_CH1_SSPD_DVALID_true();
            break;
        case RX_SYNC_CH2:
            *Locked = VRX_is_CH2_SSPD_DVALID_true();
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);    
}

/*============================================================================
 * Set the STDI measurement mode
 *
 * Entry:   StdiMode: Sets the STDI measurement mode
 *          SyncCh: Sync channel for which the STDI measurement mode must be 
 *                  set
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpGetStdiMsrmt
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetStdiMode (RX_CP_MSRMT_MODE StdiMode, RX_SYNC_CH SyncCh)
{

    UINT8 i;

    
    i = (UCHAR)(ATV_LookupValue8 ((UCHAR*)StdiModeCfg, 
                                                (UCHAR)StdiMode, 0xff, 3));
    if(StdiModeCfg[i] == 0xff)
    {
        return (ATVERR_INV_PARM);
    }
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            VRX_set_CH1_STDI_CONT(StdiModeCfg[i+1]);
            VRX_set_BYPASS_STDI1_LOCKING(StdiModeCfg[i+2]); 
            break;
        case RX_SYNC_CH2:
            VRX_set_CH2_STDI_CONT(StdiModeCfg[i+1]);
            VRX_set_BYPASS_STDI2_LOCKING(StdiModeCfg[i+2]);   
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Return the STDI measurement for a selected sync channel
 *
 * Entry:   StdiInfo: STDI measurement
 *          SyncCh: Sync channel for which the STDI measurement must be 
 *                  returned
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_FAILED = Valid SSPD measurement not available
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpSetStdiMode
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetStdiMsrmt (RX_STDI_INFO *StdiInfo, RX_SYNC_CH SyncCh)
{
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            if(!VRX_is_CH1_STDI_CONT_true())
            {
                VRX_set_CH1_TRIG_STDI(1);
                VRX_set_CH1_TRIG_STDI(0);
            }
            StdiInfo->BlockLength = VRX_ret_CH1_BL();
            StdiInfo->LinesVsync = VRX_ret_CH1_LCVS();
            StdiInfo->LinesField = VRX_ret_CH1_LCF();
            StdiInfo->FieldLength = VRX_ret_CH1_FCL();
            StdiInfo->Interlaced = VRX_is_CH1_STDI_INTLCD_true();
            if(!VRX_is_CH1_STDI_DVALID_true())
            {
                return (ATVERR_FAILED);
            }
            break;
        case RX_SYNC_CH2:
            if(!VRX_is_CH2_STDI_CONT_true())
            {
                VRX_set_CH2_TRIG_STDI(1);
                VRX_set_CH2_TRIG_STDI(0);
            }
            StdiInfo->BlockLength = VRX_ret_CH2_BL();
            StdiInfo->LinesVsync = VRX_ret_CH2_LCVS();
            StdiInfo->LinesField = VRX_ret_CH2_LCF();
            StdiInfo->FieldLength = VRX_ret_CH2_FCL();
            StdiInfo->Interlaced = VRX_is_CH2_STDI_INTLCD_true();
            if(!VRX_is_CH2_STDI_DVALID_true())
            {
                return (ATVERR_FAILED);
            }
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Returns the lock status of the STDI for a selected sync channel
 *
 * Entry:   Locked: lock status of the STDI in sync channel SyncCh
 *          SyncCh: Sync channel for which the STDI lock status must be 
 *                  returned           
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetStdiStatus (BOOL *Locked, RX_SYNC_CH SyncCh)
{
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            *Locked = VRX_is_CH1_STDI_DVALID_true();
            break;
        case RX_SYNC_CH2:
            *Locked = VRX_is_CH2_STDI_DVALID_true();
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);    
}
#endif
