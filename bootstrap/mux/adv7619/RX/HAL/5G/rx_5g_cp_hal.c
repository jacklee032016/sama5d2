/**********************************************************************************************
*																						      *
* Copyright (c) 2015 Analog Devices, Inc.  All Rights Reserved.                               *
* This software is proprietary and confidential to Analog Devices, Inc. and its licensors.    *
*                                                                                             *
***********************************************************************************************/
/*============================================================================
 * This file contains all functions that are chip-specific
 *
 *===========================================================================*/
#include "rx_lib.h"
#include "rx_hal.h"
#if ((RX_DEVICE == 7612) || (RX_DEVICE == 7611) || (RX_DEVICE == 7619))

#include "rx_isr.h"

CONSTANT UCHAR RxCpMaskRegs[] = 
{
    VRX_REG_INTERRUPT_MASKB_1, VRX_REG_INTERRUPT2_MASKB_1, INT_MASK_B1,
    VRX_REG_INTERRUPT_MASKB_6, VRX_REG_INTERRUPT2_MASKB_6, INT_MASK_B6,
    0, 0
};
EXTERNAL CONSTANT UCHAR StdiModeCfg[];
EXTERNAL CONSTANT UCHAR SspdModeCfg[];
/*============================================================================
 * Retun the gain mode
 *
 * Entry:   GainMode: RX_GAIN_AUTO = Gain automatically computed and dependant
 *                                   the output range
 *                    RX_GAIN_AGC =  Gain generated by the AGC section
 *                    RX_GAIN_MAN = Gain manually set by user
 *
 * Return:  ATVERR_OK = Function completed successfully
 *
 * Notes:   See also ADIAPI_RxCpSetGain
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetGainMode (RX_GAIN_MODE *GainMode)
{
    UINT8 AgcMode;
    UINT8 GainMan;
    
    
    VRX_get_AGC_MODE_MAN(&AgcMode);
    VRX_get_GAIN_MAN(&GainMan);
    if(AgcMode)
    {
        if(GainMan)
        {
            *GainMode = RX_GAIN_MAN;
        }
        else
        {
            *GainMode = RX_GAIN_AGC;
        }
    }
    else
    {
        *GainMode = RX_GAIN_AUTO;
    }
    return (ATVERR_OK);
}

/*============================================================================
 * This function enables manual mode gain and sets the gain for each processing c
 * channel of the CP core.
 * 
 * Entry:   GainChA:  Channel A Gain
 *          GainChB:  Channel B Gain
 *          GainChC:  Channel C Gain
 *          
 *  
 * Return:  ATVERR_OK
 *          
 * Notes:   The gain registers are sequenced and should be written to in order
 *          with no other I2C activity in between.
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetGain (UINT16 GainChA, UINT16 GainChB, UINT16 GainChC)
{
    UINT16 GainWrSeq[4];

    GainWrSeq[0]= ((GainChA >> 4) & 0x3FF) | (0xC0);
    GainWrSeq[1]= (((GainChA & 0x00F) << 4) | ( (GainChB & 0x3C0) >>6));
    GainWrSeq[2]= (((GainChB & 0x03F) << 2) | ( (GainChC & 0x300) >>8));
    GainWrSeq[3]= ( GainChC & 0x0FF);
    HAL_I2CWriteByte(VRX_CP_MAP_ADDR,VRX_REG_GAIN_CNTRL_3 , GainWrSeq[0]); 
    HAL_I2CWriteByte(VRX_CP_MAP_ADDR,VRX_REG_GAIN_CNTRL_4, GainWrSeq[1]);
    HAL_I2CWriteByte(VRX_CP_MAP_ADDR,VRX_REG_GAIN_CNTRL_5, GainWrSeq[2]);
    HAL_I2CWriteByte(VRX_CP_MAP_ADDR,VRX_REG_GAIN_CNTRL_6, GainWrSeq[3]);
    return (ATVERR_OK);
}
/*============================================================================
 * This function is used to enable or disable CP events
 *
 * Entry:   EventList: A pointer to a list of CP event that must be enabled
 *                     Non CP event are discared by this function
 *          ListSize: The number of event in the listed pointed by EvntList
 *          Enable: TRUE = List of events pointed by EventList must be enabled
 *                  FALSE = List of events pointed by EventList must be disabled
 *  
 * Return:  
 *
 * Notes:   None
 *
 *===========================================================================*/
UCHAR HAL_RxCpSetEnabledEvents (RX_EVENT *EventList, UCHAR ListSize, BOOL Enable)
{
    UINT8 i, j, IntIdx, IntCount=0, MaskVal[NOF_RX_MASK_REGS];
    IntIdx = HAL_RxGetIntIndex();

    /*=======================================
     * Get interrupt mask values
     *======================================*/
    for (i=0; RxCpMaskRegs[i]; i+=3)
    {
        HAL_I2CReadByte(VRX_IO_MAP_ADDR, RxCpMaskRegs[IntIdx+i], &(MaskVal[RxCpMaskRegs[i+2]]));
    }

    /*====================================
     * Enable/disable required events
     *===================================*/
    for (i=0; i<ListSize; i++)
    {
        for (j=0; RxMaskInfo[j].Event != 0xff; j++)
        {
            if (RxMaskInfo[j].Event == EventList[i])
            {
                MaskVal[RxMaskInfo[j].Reg1] &= ~(RxMaskInfo[j].Mask1[IntIdx]);
                RX_EVENT_DISABLE(EventList[i]);
                if (Enable)
                {
                    MaskVal[RxMaskInfo[j].Reg1] |= RxMaskInfo[j].Mask1[IntIdx];
                    RX_EVENT_ENABLE(EventList[i]);
                }
                if (RxMaskInfo[j].Reg2 != 0xff)
                {
                    MaskVal[RxMaskInfo[j].Reg2] &= ~(RxMaskInfo[j].Mask2[IntIdx]);
                    if (Enable)
                    {
                        MaskVal[RxMaskInfo[j].Reg2] |= RxMaskInfo[j].Mask2[IntIdx];
                    }
                }
                IntCount++;
                break;
            }
        }
        switch(EventList[i])
        {
            case RX_EVENT_CP_STDI_LCK:
                VRX_set_STDI_DATA_VALID_EDGE_SEL((Enable)? 1: 0);
                break;
            default:
                break;
        }
    }

    /*=======================================
     * Update interrupt masks
     *======================================*/
    for (i=0; RxCpMaskRegs[i]; i+=3)
    {
        HAL_I2CWriteByte(VRX_IO_MAP_ADDR, RxCpMaskRegs[IntIdx+i], MaskVal[RxCpMaskRegs[i+2]]);
    }

    /*=======================================
     * Clear masks for unused interrupt
     *======================================*/
    IntIdx = (~IntIdx) & 1;
    for (i=0; RxCpMaskRegs[i]; i+=3)
    {
        HAL_I2CWriteByte(VRX_IO_MAP_ADDR, RxCpMaskRegs[IntIdx+i], 0);
    }
  
    return(IntCount);
}


/*==========================================================================
 * Finds out all the active nad unmasked CP interrupts. It clears all the 
 * active interupts on return.
 *
 * Entry:   RxCpInts = is a BOOL array that contains status of all the HDMI
 *                      interrupts
 * 
 * Notes:  None
 *=========================================================================*/
void HAL_RxCpGetInterrupts(RX_CP_INTERRUPTS *RxCpInts)
{
    UINT8 IntStatus1, IntStatus6;
        
    HAL_I2CReadByte(VRX_IO_MAP_ADDR, VRX_REG_INTERRUPT_STATUS_1, &IntStatus1);
    HAL_I2CReadByte(VRX_IO_MAP_ADDR, VRX_REG_INTERRUPT_STATUS_6, &IntStatus6);

    /*==================================================================
     * Acknowledge all interrupts immediately so we don't lose any
     *=================================================================*/
    HAL_I2CWriteByte(VRX_IO_MAP_ADDR, VRX_REG_INTERRUPT_CLEAR_1, IntStatus1);
    HAL_I2CWriteByte(VRX_IO_MAP_ADDR, VRX_REG_INTERRUPT_CLEAR_6, IntStatus6);
     
    RxCpInts->CpLckChng = (BOOL) ((IntStatus1 & VRX_BIT_CP_LOCK_ST) | 
                                  (IntStatus1 & VRX_BIT_CP_UNLOCK_ST));
    RxCpInts->StdiLckChng = (BOOL) (IntStatus6 & VRX_BIT_STDI_DVALID_CH1_ST);    

    RxCpInts->CpCh1LckChng = (BOOL) ((IntStatus6 & VRX_BIT_CP_LOCK_CH1_ST) | 
                                    (IntStatus6 & VRX_BIT_CP_UNLOCK_CH1_ST));
    RxCpInts->StdiCh1LckChng = (BOOL) (IntStatus6 & VRX_BIT_STDI_DVALID_CH1_ST);
   

}

/*============================================================================
 * This function is used to if CP events that can't be notified by the 
 * ISR have occurred
 *
 * Entry:   None
 *  
 * Return:  void
 *
 * Notes:   None
 *
 *===========================================================================*/
void HAL_RxCpHouseKeeping (void)
{
    BOOL StdiLock, SspdLock;
    UINT8 ByteX;
    RX_SYNC_CH SyncCh;
    
    if (RX_EVENT_IS_ENABLED(RX_EVENT_CP_STDI_LCK))
    {
        ADIAPI_RxCpGetMainSyncCh (&SyncCh);
        ADIAPI_RxCpGetSspdStatus (&SspdLock, SyncCh);
        ADIAPI_RxCpGetStdiStatus (&StdiLock, SyncCh);
        if (SspdLock != CurrSspdLock)
        {
            CurrSspdLock = SspdLock;
            ByteX = ((SspdLock && StdiLock) ? 1 :0); 
            RX_NOTIFY_USER(RX_EVENT_CP_STDI_LCK, 0, &ByteX);
        }
    }

    if (RX_EVENT_IS_ENABLED(RX_EVENT_CP_STDI_LCK_SYNC_CH1)) 
    {
        ADIAPI_RxCpGetSspdStatus (&SspdLock, RX_SYNC_CH1);
        ADIAPI_RxCpGetStdiStatus (&StdiLock, RX_SYNC_CH1);
        if (SspdLock != CurrSspdLockCh1)
        {
            CurrSspdLockCh1 = SspdLock;
            ByteX = ((SspdLock && StdiLock) ? 1:0); 
            RX_NOTIFY_USER(RX_EVENT_CP_STDI_LCK_SYNC_CH1, 0, &ByteX);
        }
    }

   
}
/*============================================================================
 * Route the input syncs to a specific sync channel
 *
 * Entry:   Hsync: The hsync to route
 *          Vsync: The vsync to route
 *          EmbSync: The embedded sync to route
 *          SyncCh: The sync channel the input sync must be routed to
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 * Notes:   None
 *
 *===========================================================================*/
ATV_ERR HAL_CpRouteSyncToSyncCh (RX_HS_SEL Hsync, RX_VS_SEL Vsync, RX_EMBSYNC_SEL EmbSync, RX_SYNC_CH SyncCh)
{  return  (ATVERR_NOT_AVAILABLE);

}
/*============================================================================
 * Return the sync channel that is being processed by the CP section
 *
 * Entry:   SyncCh : The CP section is currently processing channel SyncCh  
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *
 * Notes:   See also ADIAPI_RxCpRouteSyncToSyncCh, ADIAPI_RxCpEnSyncChAutoMode,
 *          ADIAPI_RxCpSetMainSyncCh
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetMainSyncCh (RX_SYNC_CH *SyncCh)
{
   
        *SyncCh = RX_SYNC_CH1;
         return (ATVERR_OK);
}
/*============================================================================
 * Select the type of sync that is used by a specific syn channel
 *
 * Entry:   SyncSrc: type of sync processed by the sync channel SyncCh 
 *          SyncCh: Sync channel to which sync must be routed to        
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpEnSyncChAutoMode, ADIAPI_RxCpSetMainSyncCh
 *          ADIAPI_RxCpGetMainSyncCh
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetSyncChSource (RX_SYNC_SRC SyncSrc, RX_SYNC_CH SyncCh)
{
     return  (ATVERR_NOT_AVAILABLE);
}

/*============================================================================
 * Set the selection mode of the sync channel processed by the CP section
 *
 * Entry:   Enable : ATV_TRUE =  Enable automatic selection of the sync 
 *                               channel processed by the CP section
 *                   ATV_FALSE =  Enable manual selection of the sync 
 *                               channel processed by the CP section        
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *
 * Notes:   See also ADIAPI_RxCpRouteSyncToSyncCh, ADIAPI_RxCpSetMainSyncCh
 *          ADIAPI_RxCpGetMainSyncCh
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpEnSyncChAutoMode (BOOL Enable)
{
    return (ATVERR_NOT_AVAILABLE);
}

/*============================================================================
 * Set the sync channel that is proccesed in manual sync selection mode.
 * Set the priority order of the sync processed by the CP section in automatic 
 * sync selection mode. 
 *
 * Entry:   SyncCh : The CP section processes channel SyncCh in 
 *                   manual sync selection mode.
 *                   The CP section prioritarily processes channel SyncCh in 
 *                   automatic sync selection mode.     
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpRouteSyncToSyncCh, ADIAPI_RxCpEnSyncChAutoMode,
 *          ADIAPI_RxCpGetMainSyncCh
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetMainSyncCh (RX_SYNC_CH SyncCh)
{
    return (ATVERR_NOT_AVAILABLE);
}





/*============================================================================
 * Set the SSPD measurement mode
 *
 * Entry:   SspdMode: Sets the SSPD measurement mode
 *          SyncCh: Sync channel for which the SSPD measurement mode must be 
 *                  set
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCPGetSspdMsrmt
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetSspdMode (RX_CP_MSRMT_MODE SspdMode, RX_SYNC_CH SyncCh)
{
   return (ATVERR_NOT_AVAILABLE);
}

/*============================================================================
 * Return the SSPD measurement for a selected sync channel
 *
 * Entry:   SspdInfo: SSPD measurement
 *          SyncCh: Sync channel for which the SSPD measurement must be 
 *                  returned
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_FAILED = Valid SSPD measurement not available
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpSetSspdMode
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetSspdMsrmt (RX_SSPD_INFO *SspdInfo, RX_SYNC_CH SyncCh)
{
   return (ATVERR_NOT_AVAILABLE);

}

/*============================================================================
 * Returns the lock status of the SSPD for a selected sync channel
 *
 * Entry:   Locked: lock status of the SSPD in sync channel SyncCh
 *          SyncCh: Sync channel for which the STDI lock status must be 
 *                  returned           
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetSspdStatus (BOOL *Locked, RX_SYNC_CH SyncCh)
{
   switch(SyncCh)
    {
        case RX_SYNC_CH1:
            *Locked = VRX_is_CH1_SSPD_DVALID_true();
            break;
        case RX_SYNC_CH2:
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);    
}

/*============================================================================
 * Set the STDI measurement mode
 *
 * Entry:   StdiMode: Sets the STDI measurement mode
 *          SyncCh: Sync channel for which the STDI measurement mode must be 
 *                  set
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpGetStdiMsrmt
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpSetStdiMode (RX_CP_MSRMT_MODE StdiMode, RX_SYNC_CH SyncCh)
{

    UINT8 i;

    
    i = (UCHAR)(ATV_LookupValue8 ((UCHAR*)StdiModeCfg, 
                                                (UCHAR)StdiMode, 0xff, 3));
    if(StdiModeCfg[i] == 0xff)
    {
        return (ATVERR_INV_PARM);
    }
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            VRX_set_CH1_STDI_CONT(StdiModeCfg[i+1]);
            VRX_set_BYPASS_STDI1_LOCKING(StdiModeCfg[i+2]); 
            break;
       
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Return the STDI measurement for a selected sync channel
 *
 * Entry:   StdiInfo: STDI measurement
 *          SyncCh: Sync channel for which the STDI measurement must be 
 *                  returned
 * 
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_FAILED = Valid SSPD measurement not available
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:   See also ADIAPI_RxCpSetStdiMode
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetStdiMsrmt (RX_STDI_INFO *StdiInfo, RX_SYNC_CH SyncCh)
{
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            if(!VRX_is_CH1_STDI_CONT_true())
            {
                VRX_set_CH1_TRIG_STDI(1);
                VRX_set_CH1_TRIG_STDI(0);
            }
            StdiInfo->BlockLength = VRX_ret_CH1_BL();
            StdiInfo->LinesVsync = VRX_ret_CH1_LCVS();
            StdiInfo->LinesField = VRX_ret_CH1_LCF();
            StdiInfo->FieldLength = VRX_ret_CH1_FCL();
            StdiInfo->Interlaced = VRX_is_CH1_STDI_INTLCD_true();
            if(!VRX_is_CH1_STDI_DVALID_true())
            {
                return (ATVERR_FAILED);
            }
            break;
       
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Returns the lock status of the STDI for a selected sync channel
 *
 * Entry:   Locked: lock status of the STDI in sync channel SyncCh
 *          SyncCh: Sync channel for which the STDI lock status must be 
 *                  returned           
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid input parameter
 *
 * Notes:
 *
 *===========================================================================*/
ATV_ERR HAL_RxCpGetStdiStatus (BOOL *Locked, RX_SYNC_CH SyncCh)
{
    switch(SyncCh)
    {
        case RX_SYNC_CH1:
            *Locked = VRX_is_CH1_STDI_DVALID_true();
            break;
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);    
}

/*============================================================================
 * Set the CSC Mode. This API is used to decide if a specific CSC is used.  
 *
 * Entry:   Mode: Set the enable mode the CSC is set into
 *              RX_CS_AUTO_EN = 1,
 *              RX_CS_MAN_EN,
 *              RX_CS_MAN_DIS,
 *          Csc: Color space converster 
 *              DPP_CSC
 *              CP_CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ADIERR_INV_PARM = Invalid parameter
 *
 * Notes:   The entire DPP is enabled when the DPP_CSC is enabled
 *          See also ADIAPI_RxDppEn
 *          This function should be the very first CSC function to be called
 *          before calling any other CSC function (e.g. ADIAPI_RxSetCscConfig)
 *
 *===========================================================================*/
ATV_ERR HAL_RxSetCscMode(RX_CSC_MODE Mode, RX_CSC Csc)
{
   switch(Csc)
    {
       
        case RX_CP_CSC:
            switch(Mode)
            {
                case RX_CS_AUTO_EN:
                   VRX_set_MAN_CP_CSC_EN(0);
                    break;
                case RX_CS_MAN_EN:
                   VRX_set_MAN_CP_CSC_EN(1);
                    break;
                case RX_CS_MAN_DIS:
                   return (ATVERR_INV_PARM);
                default:
                    return (ATVERR_INV_PARM);
            }
            break;
        case RX_SDP_CSC:
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}
/*============================================================================
 * Return the enable mode a CSC is set into
 *
 * Entry:   EnMode: The enable mode the CSC is set into
 *          Csc: Specifies the CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *
 * Notes:   None
 *
 *===========================================================================*/
ATV_ERR HAL_RxGetCscMode(RX_CSC_MODE *Mode, RX_CSC Csc)
{
    switch(Csc)
    {
        
        case RX_CP_CSC:
           
                if(VRX_is_MAN_CP_CSC_EN_true())
                {
                    *Mode = RX_CS_MAN_EN;
                }
                else
                {
                    *Mode = RX_CS_AUTO_EN;
                }
            break;
        case RX_SDP_CSC:
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}
/*============================================================================
 * Set the configuration of a CSC. This function can be used to decide wether 
 * internal (i.e. hardcoded) or manual CSC coefficients are used for a 
 * specific CSC 
 *
 * Entry:   Config: Configuration of the CSC
 *          Csc: DPP_CSC
 *               CP_CSC
 *               SDP_CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *
 * Notes:   None
 *
 *===========================================================================*/
ATV_ERR HAL_RxSetCscConfig(RX_CSC_CONFIG Config, RX_CSC Csc)
{ 
    RX_CSC_MODE CpMode;
    ATV_ERR CpRet;

    CpRet = HAL_RxGetCscMode(&CpMode, RX_CP_CSC);
    if(CpRet ==ATVERR_FAILED)
    {
    	return (ATVERR_FAILED);
    }
    switch(Csc)
    {
        case RX_CP_CSC:
            switch(Config)
            {
                case RX_CS_AUTO:
                    if((CpMode == RX_CS_MAN_EN) || (CpMode == RX_CS_AUTO_EN))
                    {
                        VRX_set_CSC_COEFF_SEL(0xf);
                    }
                    else
                    {
                        return (ATVERR_FAILED);
                    }
                    break;
                case RX_CS_MAN:
                    if((CpMode == RX_CS_MAN_EN) || (CpMode == RX_CS_AUTO_EN))
                    {
                            VRX_set_CSC_COEFF_SEL(0);
                    }
                    else
                    {
                        return (ATVERR_FAILED);
                    }
                    break;
                default:
                    return (ATVERR_INV_PARM);
            }
            break;
        case RX_SDP_CSC:
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Return the Mode a CSC is set into
 *
 * Entry:   Mode: The mode the CSC is set into
 *          Csc: Specifies the CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *          ATVERR_FAILED = The configuration requested is not valid or
 *                          not possible
 *
 * Notes:   None
 *
 *===========================================================================*/
ATV_ERR HAL_RxGetCscConfig(RX_CSC_CONFIG *Config, RX_CSC Csc)
{
    RX_CSC_MODE CpMode;
    UINT8 CscCoeffSel;

    HAL_RxGetCscMode(&CpMode, RX_CP_CSC);
    switch(Csc)
    {
        case RX_CP_CSC:
            /* Check if the CP CSC is enabled
             * This check condition my need to be reviewed as the CP CSC
             * is disabled when the out put is decimated and CP CSC in
             * auto mode
             * */
            if((CpMode == RX_CS_AUTO_EN)  || (CpMode == RX_CS_MAN_EN)) 
            {
                CscCoeffSel = VRX_ret_CSC_COEFF_SEL();
                if(CscCoeffSel == 0xf)
                {
                    *Config = RX_CS_AUTO;
                }
                else if(CscCoeffSel == 0)
                {
                     *Config = RX_CS_MAN;
                }
            }
            else
            {
                return (ATVERR_FAILED);
            }
            break;
        case RX_SDP_CSC:
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}
/*============================================================================
 * Get the input color space of a CSC
 *
 * Entry:   ColorSpace: Set the input color space of the CSC.
 *          Range: Set the input range of the video input to the
 *                 CSC or/and the CP section
 *          Csc: DPP_CSC
 *               CP_CSC
 *               SDP_CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *          ATVERR_FAILED = The function failed to
 *
 * Notes:   See also ADIAPI_RxGetIpColorSpace, ADIAPI_RxSetOpColorSpace
 *          ADIAPI_RxGetOpColorSpace
 *
 *===========================================================================*/
ATV_ERR HAL_RxSetIpColorSpace(RX_CS_COLOR ColorSpace, RX_RANGE Range, RX_CSC Csc)
{
    RX_CSC_CONFIG CscConfig;
    ATV_ERR Ret = ATVERR_FAILED;

    Ret = HAL_RxGetCscConfig(&CscConfig, Csc);
    if(Ret != ATVERR_OK)
    {
        return (ATVERR_FAILED);
    }
    
    switch(Csc)
    {
        case RX_CP_CSC:
            
            if(CscConfig == RX_CS_AUTO)
            {
                return (HAL_RxSetAutoIpColorSpace(ColorSpace, Range, RX_CP_CSC));
            }
            break;
        case RX_SDP_CSC:
        default:
            return (ATVERR_INV_PARM);
    }
    return (ATVERR_FAILED);
}
/*============================================================================
 * Set the input color space for a CSC configured in automatic mode
 *
 * Entry:   Mode: The mode the CSC is set into
 *          Csc: Specifies the CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *
 * Notes:   This function does not check if the CSC is configured in automatic
 *          mode. This function simply configure the input color space of a CSC
 *          assuming that it has already been configured in automatic mode
 *
 *===========================================================================*/
ATV_ERR HAL_RxSetAutoIpColorSpace(RX_CS_COLOR ColorSpace, RX_RANGE Range, RX_CSC Csc)
{
 
    if((Csc == RX_CP_CSC) )
    {
        switch(ColorSpace)
        {
            case RX_CS_FOLLOW_INPUT:
                VRX_set_INP_COLOR_SPACE(0xf);
                break;
            case RX_CS_RGB:
                if(Range == RX_RG_16_235)
                {
                    VRX_set_INP_COLOR_SPACE(0);
                }
                else if(Range == RX_RG_0_255)
                {
                    VRX_set_INP_COLOR_SPACE(0x1);
                }
                break;
            case RX_CS_YCrCb601:
                if(Range == RX_RG_16_235)
                {
                    VRX_set_INP_COLOR_SPACE(0x2);
                }
                else if(Range == RX_RG_0_255)
                {
                    VRX_set_INP_COLOR_SPACE(0x6);
                }
                break;
            case RX_CS_YCrCb709:
                if(Range == RX_RG_16_235)
                {
                    VRX_set_INP_COLOR_SPACE(0x3);
                }
                else if(Range == RX_RG_0_255)
                {
                    VRX_set_INP_COLOR_SPACE(0x7);
                }
                break;
            case RX_CS_XVYCC601:
                VRX_set_INP_COLOR_SPACE(0x4);
                break;
            case RX_CS_XVYCC709:
                VRX_set_INP_COLOR_SPACE(0x5);
                break;
            default:
                return (ATVERR_INV_PARM);
        }
    }
    else if (Csc == RX_SDP_CSC)
    {
        return (ATVERR_INV_PARM);
    }
    else
    {
        return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Get the input color space of a CSC
 *
 * Entry:   ColorSpace: The input color space of the CSC.
 *          Range: Get the input range of the video input to the
 *                 CSC or/and the CP section
 *          Csc: DPP_CSC
 *               CP_CSC
 *               SDP_CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *          ATVERR_FAILED = The function failed to return valid information
 *                          (the CSC may be set in manual mode)
 *
 * Notes:   See also ADIAPI_RxSetIpColorSpace, ADIAPI_RxSetOpColorSpace
 *          ADIAPI_RxGetOpColorSpace
 *
 *===========================================================================*/
ATV_ERR HAL_RxGetIpColorSpace(RX_CS_COLOR *ColorSpace, RX_RANGE *Range, RX_CSC Csc)
{
    RX_CSC_CONFIG CscConfig;
    ATV_ERR Ret= ATVERR_FAILED;

    Ret = HAL_RxGetCscConfig(&CscConfig, Csc);
    if(Ret != ATVERR_OK)
    {
        return (ATVERR_FAILED);
    }
    if(Csc == RX_CP_CSC)
    {
        if(CscConfig != RX_CS_AUTO)
        {
            return (ATVERR_FAILED);
        }
        Ret = HAL_RxGetAutoIpColorSpace(ColorSpace, Range, Csc);
        if(Ret != ATVERR_OK)
        {
            return (ATVERR_FAILED);
        }
    }
    else
    {
        return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
    
}
/*============================================================================
 * Get the output color space for a CSC configured in automatic mode
 *
 * Entry:   Mode: Output colorspace
 *          Csc: Specifies the CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *          ATVERR_ERR = the input color space is not available
 *
 * Notes:   This function does not check if the CSC is configured in automatic
 *          mode. This function simply returns the input color space of a CSC
 *          assuming that it has already been configured in automatic mode
 *
 *===========================================================================*/
ATV_ERR HAL_RxGetAutoIpColorSpace(RX_CS_COLOR *ColorSpace, RX_RANGE *Range, RX_CSC Csc)
{
    UINT8 CscConv;
    UINT8 PrimMode;
    UINT8 VidStd;


    if(Csc == RX_CP_CSC )
    {
        CscConv = VRX_ret_INP_COLOR_SPACE();
        switch(CscConv)
        {
            case 0:
                *ColorSpace = RX_CS_RGB;
                *Range = RX_RG_16_235;
                break;
            case 0x1:
                *ColorSpace = RX_CS_RGB;
                *Range = RX_RG_0_255;
                break;
            case 0x2:
                *ColorSpace = RX_CS_YCrCb601;
                *Range = RX_RG_16_235;
                break;
            case 0x3:
                *ColorSpace = RX_CS_YCrCb709;
                *Range = RX_RG_16_235;
                break;
            case 0x4:
                *ColorSpace = RX_CS_XVYCC601;
                *Range = RX_RG_0_255;
                break;
            case 0x5:
                *ColorSpace = RX_CS_XVYCC709;
                *Range = RX_RG_0_255;
                break;
            case 0x6:
                *ColorSpace = RX_CS_YCrCb601;
                *Range = RX_RG_0_255;
                break;
            case 0x7:
                *ColorSpace = RX_CS_YCrCb601;
                *Range = RX_RG_0_255;
                break;
            case 0xf:
                PrimMode = VRX_ret_PRIM_MODE();
                VidStd = VRX_ret_VID_STD();
                if((PrimMode == 0x1) && (VidStd <= 0x9))
                {
                    *ColorSpace = RX_CS_YCrCb601;
                    *Range = RX_RG_0_255;
                }
                else if((PrimMode == 0x1) && (VidStd > 0x9))
                {
                    *ColorSpace = RX_CS_YCrCb709;
                    *Range = RX_RG_0_255;
                }
                else if((PrimMode == 0x5) || (PrimMode == 0x6))
                {
                    HAL_RxGetHdmiOpColorSpace(ColorSpace);
                    HAL_RxGetHdmiOpRange(Range);
                }
                else
                {
                    return (ATVERR_FAILED);
                }
                break;
            default:
                return (ATVERR_FAILED);
        }
    }
    else
    {
        return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}

/*============================================================================
 * Set the output color space of a CSC
 *
 * Entry:   ColorSpace: Set the input color space of the CSC.
 *                  The input range is also set by this function
 *          Csc: DPP_CSC
 *               CP_CSC
 *               SDP_CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_IN_PARM = Invalid parameter
 *          ATVERR_FAILED = The function is set in manual mode)
 *
 * Notes:   See also ADIAPI_RxSetIpColorSpace, ADIAPI_RxGetIpColorSpace
 *          ADIAPI_RxGetOpColorSpace
 *
 *===========================================================================*/
ATV_ERR HAL_RxSetOpColorSpace(RX_CS_COLOR ColorSpace, RX_CSC Csc)
{
   
    RX_CSC_CONFIG CscConfig;
    ATV_ERR Ret;

    Ret = HAL_RxGetCscConfig(&CscConfig, Csc);
    if(Ret != ATVERR_OK)
    {
        return (ATVERR_FAILED);
    }
    if(Csc == RX_CP_CSC)
    {
        if(CscConfig != RX_CS_AUTO)
        {
            return (ATVERR_FAILED);
        }
        Ret = HAL_RxSetAutoOpColorSpace(ColorSpace, Csc);
        if(Ret != ATVERR_OK)
        {
            return (ATVERR_FAILED);
        }
    }
    else
    {
        return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
    
}
/*============================================================================
 * Set the output color space for a CSC configured in automatic mode
 *
 * Entry:   ColorSpace: Output colorspace
 *          Csc: Specifies the CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *
 * Notes:   This function does not check if the CSC is configured in automatic
 *          mode. This function simply returns the input color space of a CSC
 *          assuming that it has already been configured in automatic mode
 *
 *===========================================================================*/
ATV_ERR HAL_RxSetAutoOpColorSpace(RX_CS_COLOR ColorSpace, RX_CSC Csc)
{
    UINT8 RgbOut = 0;
    UINT8 AltGamma = 0;
    RX_CS_COLOR IpColorSpace = RX_CS_RGB;
    RX_RANGE IpRange;

    if(Csc == RX_CP_CSC )
    {
        HAL_RxGetAutoIpColorSpace(&IpColorSpace, &IpRange, Csc);
        switch(ColorSpace)
        {
            case RX_CS_RGB:
                RgbOut = 1;
                break;
            case RX_CS_YCrCb601:
                switch(IpColorSpace)
                {
                    case RX_CS_RGB:
                        AltGamma = 0;
                        break;
                    case RX_CS_YCrCb601:
                        AltGamma = 0;
                        break;
                    case RX_CS_YCrCb709:
                        AltGamma = 1;
                        break;
                    default:
                        return (ATVERR_FAILED);
                }
                break;
            case RX_CS_YCrCb709:
                switch(IpColorSpace)
                {
                    case RX_CS_RGB:
                        AltGamma = 0;
                        break;
                    case RX_CS_YCrCb601:
                        AltGamma = 1;
                        break;
                    case RX_CS_YCrCb709:
                        AltGamma = 0;
                        break;
                    default:
                        return (ATVERR_FAILED);
                }
                break;
            default:
                return (ATVERR_INV_PARM);
        }
    }
    else
    {
        return (ATVERR_INV_PARM);
    }
    VRX_set_RGB_OUT(RgbOut);
    VRX_set_ALT_GAMMA(AltGamma);
    return (ATVERR_OK);
}
/*============================================================================
 * Returns the output color space of a CSC
 *
 * Entry:   ColorSpace: The input color space of the CSC.
 *                  The input range is also set by this function
 *          Csc: DPP_CSC
 *               CP_CSC
 *               SDP_CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *          ATVERR_FAILED = The function failed to return valid information
 *                          (the CSC may be set in manual mode)
 *
 * Notes:   See also ADIAPI_RxSetIpColorSpace, ADIAPI_RxGetIpColorSpace
 *          ADIAPI_RxSetOpColorSpace
 *
 *===========================================================================*/
ATV_ERR HAL_RxGetOpColorSpace(RX_CS_COLOR *ColorSpace, RX_CSC Csc)
{
    RX_CSC_CONFIG CscConfig;
    ATV_ERR Ret;

    Ret = HAL_RxGetCscConfig(&CscConfig, Csc);
    if(Ret != ATVERR_OK)
    {
        return (ATVERR_FAILED);
    }
    if(Csc == RX_CP_CSC )
    {
        if(CscConfig != RX_CS_AUTO)
        {
            return (ATVERR_FAILED);
        }
        Ret = HAL_RxGetAutoOpColorSpace(ColorSpace, Csc);
        if(Ret != ATVERR_OK)
        {
            return (ATVERR_FAILED);
        }
    }
    else
    {
        return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}
/*============================================================================
 * Get the output color space for a CSC configured in automatic mode
 *
 * Entry:   ColorSpace: Output colorspace
 *          Csc: Specifies the CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *          ATVERR_ERR = the input color space is not available
 *                       (the CSC may be set in manual mode)
 *
 * Notes:   This function does not check if the CSC is configured in automatic
 *          mode. This function simply returns the input color space of a CSC
 *          assuming that it has already been configured in automatic mode
 *
 *===========================================================================*/
ATV_ERR HAL_RxGetAutoOpColorSpace(RX_CS_COLOR *ColorSpace, RX_CSC Csc)
{
    RX_CS_COLOR IpColorSpace;
    RX_RANGE IpRange;
    UINT8 RgbOut;
    UINT8 AltGamma;

    if((Csc == RX_CP_CSC))
    {
        HAL_RxGetAutoIpColorSpace(&IpColorSpace, &IpRange, Csc);
        RgbOut = VRX_ret_RGB_OUT();
        AltGamma = VRX_ret_ALT_GAMMA();
        switch(IpColorSpace)
        {
            case RX_CS_RGB:
                if(RgbOut)
                {
                    *ColorSpace = RX_CS_RGB;
                }
                else
                {
                    if(AltGamma)
                    {
                        *ColorSpace = RX_CS_YCrCb709;
                    }
                    else
                    {
                        *ColorSpace = RX_CS_YCrCb601;
                    }
                }
                break;
            case RX_CS_YCrCb601:
                if(RgbOut)
                {
                    *ColorSpace = RX_CS_RGB;
                }
                else
                {
                    if(AltGamma)
                    {
                        *ColorSpace = RX_CS_YCrCb709;
                    }
                    else
                    {
                        *ColorSpace = RX_CS_YCrCb601;
                    }
                }
                break;
            case RX_CS_YCrCb709:
                if(RgbOut)
                {
                    *ColorSpace = RX_CS_RGB;
                }
                else
                {
                    if(AltGamma)
                    {
                        *ColorSpace = RX_CS_YCrCb601;
                    }
                    else
                    {
                        *ColorSpace = RX_CS_YCrCb709;
                    }
                }
                break;
            case RX_CS_XVYCC601:
                *ColorSpace = RX_CS_XVYCC601;
                break;
            case RX_CS_XVYCC709:
                *ColorSpace = RX_CS_XVYCC709;
                break;
            default:
                return (ATVERR_FAILED);
        }
    }
    else
    {
        return (ATVERR_INV_PARM);
    }
    return (ATVERR_OK);
}
/*============================================================================
 * Configure manually a CSC
 *
 * Entry:   CscScale: CSC scale coefficient.
 *          CoeffA: A pointer to 4 coefficients for channel A
 *                  CoeffA[0] = A1
 *                  CoeffA[0] = A2
 *                  CoeffA[0] = A3
 *                  CoeffA[0] = A4
 *          CoeffB: A pointer to 4 coefficients for channel B
 *                  CoeffA[0] = B1
 *                  CoeffA[0] = B2
 *                  CoeffA[0] = B3
 *                  CoeffA[0] = B4
  *         CoeffC: A pointer to 4 coefficients for channel C
 *                  CoeffA[0] = C1
 *                  CoeffA[0] = C2
 *                  CoeffA[0] = C3
 *                  CoeffA[0] = C4
 *          Csc: DPP_CSC
 *               CP_CSC
 *               SDP_CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *          ATVERR_FAILED = The function failed to configure the CSC coefficients
 *
 * Notes:   See also ADIAPI_RxSetCscConfig, ADIAPI_RxGetManCscCoeffs
 *
 *===========================================================================*/
ATV_ERR HAL_RxSetManCscCoeffs(UINT8 CscScale, UINT8* CoeffA, UINT8* CoeffB, UINT8* CoeffC, RX_CSC CSC)
{
   
    return (ATVERR_OK);
}

/*============================================================================
 * Returns the manual configuration of a CSC
 *
 * Entry:   CscScale: CSC scale coefficient.
 *          CoeffA: A pointer to 4 coefficients for channel A
 *                  CoeffA[0] = A1
 *                  CoeffA[0] = A2
 *                  CoeffA[0] = A3
 *                  CoeffA[0] = A4
 *          CoeffB: A pointer to 4 coefficients for channel B
 *                  CoeffA[0] = B1
 *                  CoeffA[0] = B2
 *                  CoeffA[0] = B3
 *                  CoeffA[0] = B4
  *         CoeffC: A pointer to 4 coefficients for channel C
 *                  CoeffA[0] = C1
 *                  CoeffA[0] = C2
 *                  CoeffA[0] = C3
 *                  CoeffA[0] = C4
 *          Csc: DPP_CSC
 *               CP_CSC
 *               SDP_CSC
 *
 * Return:  ATVERR_OK = Function completed successfully
 *          ATVERR_INV_PARM = Invalid parameter
 *          ATVERR_FAILED = The function failed to configure the CSC coefficients
 *
 * Notes:   See also ADIAPI_RxSetCscConfig, ADIAPI_RxSetManCscCoeffs
 *
 *===========================================================================*/
ATV_ERR HAL_RxGetManCscCoeffs(UINT8 *CscScale, UINT8* CoeffA, UINT8* CoeffB, UINT8* CoeffC, RX_CSC CSC)
{
 return (ATVERR_OK);
}






#endif
